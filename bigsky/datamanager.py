import torchimport pandas as pdimport numpy as npclass DataManager:    def __init__(self, df, dtypes):        self.df = df        self.domain = dict()        self.dtype = {k: dtypes[k] for k in dtypes}        for column in df:            if column not in self.dtype:                self.dtype[column] = 'numeric' # by default                if self.df[column].dtype == 'int64':                    dom = sorted(set(self.df[column].values))            if self.dtype[column] == 'categorical':                dom = sorted(set(self.df[column].values))                self.domain[column] = dom        self.column_normalizer = 'no-op'                               def set_column_normalizer(self, name):        self.column_normalizer = 'normalize'    def normalize_column(self, column):        if self.column_normalizer == 'normalize':            from sklearn.preprocessing import normalize            return normalize(column.values[:,np.newaxis], axis=0).ravel()                    else:            return column.values[:,np.newaxis].ravel()                            def select_response(self, column):        if self.dtype[column] != 'categorical':            raise ValueError("Response type not supported: {}".format(                self.dtype[column]))        value_lookup = {v: i for (i, v) in enumerate(self.domain[column])}        return torch.LongTensor([value_lookup[v] for                                  v in self.df[column]]), len(self.domain[column])            def select(self, columns):        tensors = [self.select_single(column).float() for column in columns]        return torch.cat(tensors, dim=1)                def select_single(self, column):        raw = self.df[column]        if self.dtype[column] == 'categorical':            result = self.onehot_matrix(raw.values, self.domain[column])        else:            # otherwise normalize the continuous vectors            norm2 = self.normalize_column(raw)            result = torch.tensor(norm2).unsqueeze(dim=1)        return result    def onehot_matrix(self, vec, domain):        def onehot(value):            result = torch.zeros(len(domain))            result[domain.index(value)] = 1.            return result        onehots = [onehot(value) for value in vec]        return torch.stack(onehots)def easy_data():    data = torch.randn(10000,4)    for i in range(len(data)):        if data[i][1] * data[i][2] > 0:            data[i][3] = 1        else:            data[i][3] = 0        data[i][0] = 1.    df = pd.DataFrame(data.numpy(), columns = ['X0', 'X1', 'X2', 'Y'])    df = df.astype({"Y": int})    return df